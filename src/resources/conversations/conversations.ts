// File generated from our OpenAPI spec by Stainless.

import * as Core from 'intercom/core';
import { APIResource } from 'intercom/resource';
import { isRequestOptions } from 'intercom/core';
import * as ConversationsAPI from 'intercom/resources/conversations/conversations';
import * as Shared from 'intercom/resources/shared';
import * as CustomersAPI from 'intercom/resources/conversations/customers';
import * as PartsAPI from 'intercom/resources/conversations/parts';
import * as ReplyAPI from 'intercom/resources/conversations/reply';
import * as RunAssignmentRulesAPI from 'intercom/resources/conversations/run-assignment-rules';
import * as SearchAPI from 'intercom/resources/conversations/search';
import * as TagsAPI from 'intercom/resources/conversations/tags';

export class Conversations extends APIResource {
  tags: TagsAPI.Tags = new TagsAPI.Tags(this._client);
  search: SearchAPI.Search = new SearchAPI.Search(this._client);
  reply: ReplyAPI.Reply = new ReplyAPI.Reply(this._client);
  parts: PartsAPI.Parts = new PartsAPI.Parts(this._client);
  runAssignmentRules: RunAssignmentRulesAPI.RunAssignmentRules = new RunAssignmentRulesAPI.RunAssignmentRules(
    this._client,
  );
  customers: CustomersAPI.Customers = new CustomersAPI.Customers(this._client);

  /**
   * You can create a conversation that has been initiated by a contact (ie. user or
   * lead). The conversation can be an in-app message only.
   *
   * > ðŸ“˜ Sending for visitors
   * >
   * > You can also send a message from a visitor by specifying their `user_id` or
   * > `id` value in the `from` field, along with a `type` field value of `contact`.
   * > This visitor will be automatically converted to a contact with a lead role
   * > once the conversation is created.
   *
   * This will return the Message model that has been created.
   */
  create(params: ConversationCreateParams, options?: Core.RequestOptions): Core.APIPromise<Shared.Message> {
    const { 'Intercom-Version': intercomVersion, ...body } = params;
    return this._client.post('/conversations', {
      body,
      ...options,
      headers: { 'Intercom-Version': intercomVersion?.toString() || '', ...options?.headers },
    });
  }

  /**
   * You can fetch the details of a single conversation.
   *
   * This will return a single Conversation model with all its conversation parts.
   *
   * > ðŸš§ Hard limit of 500 parts
   * >
   * > The maximum number of conversation parts that can be returned via the API
   * > is 500. If you have more than that we will return the 500 most recent
   * > conversation parts.
   *
   * > ðŸ“˜ Bot name in conversation parts
   * >
   * > For conversation parts generated by a bot, bot name will depend on the
   * > following:
   *
   * - Customers that never turned on AI answers will have `operator` as the bot name
   * - Customers that have turned on AI answers at some point will have `fin` as the
   *   bot name
   */
  retrieve(
    id: number,
    params?: ConversationRetrieveParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.Conversation>;
  retrieve(id: number, options?: Core.RequestOptions): Core.APIPromise<Shared.Conversation>;
  retrieve(
    id: number,
    params: ConversationRetrieveParams | Core.RequestOptions = {},
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.Conversation> {
    if (isRequestOptions(params)) {
      return this.retrieve(id, {}, params);
    }
    const { 'Intercom-Version': intercomVersion, ...query } = params;
    return this._client.get(`/conversations/${id}`, {
      query,
      ...options,
      headers: { 'Intercom-Version': intercomVersion?.toString() || '', ...options?.headers },
    });
  }

  /**
   * You can update an existing conversation.
   *
   * > ðŸ“˜
   * >
   * > If you want to update a conversation with either a reply (or actions such as
   * > assign, unassign, open, close or snooze) then take a look at their own
   * > sections respectively as they currently require different endpoints and
   * > parameters.
   */
  update(
    id: number,
    params?: ConversationUpdateParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.Conversation>;
  update(id: number, options?: Core.RequestOptions): Core.APIPromise<Shared.Conversation>;
  update(
    id: number,
    params: ConversationUpdateParams | Core.RequestOptions = {},
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.Conversation> {
    if (isRequestOptions(params)) {
      return this.update(id, {}, params);
    }
    const { display_as, 'Intercom-Version': intercomVersion, ...body } = params;
    return this._client.put(`/conversations/${id}`, {
      query: { display_as },
      body,
      ...options,
      headers: { 'Intercom-Version': intercomVersion?.toString() || '', ...options?.headers },
    });
  }

  /**
   * You can fetch a list of all conversations.
   *
   * You can optionally request the result page size and the cursor to start after to
   * fetch the result
   */
  list(
    params?: ConversationListParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.PaginatedResponse>;
  list(options?: Core.RequestOptions): Core.APIPromise<Shared.PaginatedResponse>;
  list(
    params: ConversationListParams | Core.RequestOptions = {},
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.PaginatedResponse> {
    if (isRequestOptions(params)) {
      return this.list({}, params);
    }
    const { 'Intercom-Version': intercomVersion, ...query } = params;
    return this._client.get('/conversations', {
      query,
      ...options,
      headers: { 'Intercom-Version': intercomVersion?.toString() || '', ...options?.headers },
    });
  }

  /**
   * You can delete a single conversation.
   */
  delete(
    id: number,
    params?: ConversationDeleteParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<ConversationDeleted>;
  delete(id: number, options?: Core.RequestOptions): Core.APIPromise<ConversationDeleted>;
  delete(
    id: number,
    params: ConversationDeleteParams | Core.RequestOptions = {},
    options?: Core.RequestOptions,
  ): Core.APIPromise<ConversationDeleted> {
    if (isRequestOptions(params)) {
      return this.delete(id, {}, params);
    }
    const { 'Intercom-Version': intercomVersion } = params;
    return this._client.delete(`/conversations/${id}`, {
      ...options,
      headers: { 'Intercom-Version': intercomVersion?.toString() || '', ...options?.headers },
    });
  }

  /**
   * You can convert a conversation to a ticket.
   */
  convert(
    id: number,
    params: ConversationConvertParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.Ticket | null> {
    const { 'Intercom-Version': intercomVersion, ...body } = params;
    return this._client.post(`/conversations/${id}/convert`, {
      body,
      ...options,
      headers: { 'Intercom-Version': intercomVersion?.toString() || '', ...options?.headers },
    });
  }

  /**
   * You can redact a conversation part or the source message of a conversation (as
   * seen in the source object).
   *
   * > ðŸ“˜ Which parts and source messages can I redact?
   * >
   * > If you are redacting a conversation part, it must have a `body`. If you are
   * > redacting a source message, it must have been created by a contact. We will
   * > return a `conversation_part_not_redactable` error if these criteria are not
   * > met.
   */
  redact(
    params: ConversationRedactParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<Shared.Conversation> {
    const { 'Intercom-Version': intercomVersion, ...body } = params;
    return this._client.post('/conversations/redact', {
      body,
      ...options,
      headers: { 'Intercom-Version': intercomVersion?.toString() || '', ...options?.headers },
    });
  }
}

/**
 * deleted conversation object
 */
export interface ConversationDeleted {
  /**
   * The unique identifier for the conversation.
   */
  id?: string;

  /**
   * Whether the conversation is deleted or not.
   */
  deleted?: boolean;

  /**
   * always conversation
   */
  object?: 'conversation';
}

export interface ConversationCreateParams {
  /**
   * Body param: The content of the message. HTML is not supported.
   */
  body: string;

  /**
   * Body param:
   */
  from: ConversationCreateParams.From;

  /**
   * Header param: Intercom API version.</br>By default, it's equal to the version
   * set in the app package.
   */
  'Intercom-Version'?:
    | '1.0'
    | '1.1'
    | '1.2'
    | '1.3'
    | '1.4'
    | '2.0'
    | '2.1'
    | '2.2'
    | '2.3'
    | '2.4'
    | '2.5'
    | '2.6'
    | '2.7'
    | '2.8'
    | '2.9'
    | '2.10'
    | 'Unstable';
}

export namespace ConversationCreateParams {
  export interface From {
    /**
     * The identifier for the contact which is given by Intercom.
     */
    id: string;

    /**
     * The role associated to the contact - user or lead.
     */
    type: 'lead' | 'user' | 'contact';
  }
}

export interface ConversationRetrieveParams {
  /**
   * Query param: Set to plaintext to retrieve conversation messages in plain text.
   */
  display_as?: string;

  /**
   * Header param: Intercom API version.</br>By default, it's equal to the version
   * set in the app package.
   */
  'Intercom-Version'?:
    | '1.0'
    | '1.1'
    | '1.2'
    | '1.3'
    | '1.4'
    | '2.0'
    | '2.1'
    | '2.2'
    | '2.3'
    | '2.4'
    | '2.5'
    | '2.6'
    | '2.7'
    | '2.8'
    | '2.9'
    | '2.10'
    | 'Unstable';
}

export interface ConversationUpdateParams {
  /**
   * Query param: Set to plaintext to retrieve conversation messages in plain text.
   */
  display_as?: string;

  /**
   * Body param: An object containing the different custom attributes associated to
   * the conversation as key-value pairs. For relationship attributes the value will
   * be a list of custom object instance models.
   */
  custom_attributes?: Record<string, string | ConversationUpdateParams.CustomObjectInstance | null>;

  /**
   * Body param: Mark a conversation as read within Intercom.
   */
  read?: boolean;

  /**
   * Header param: Intercom API version.</br>By default, it's equal to the version
   * set in the app package.
   */
  'Intercom-Version'?:
    | '1.0'
    | '1.1'
    | '1.2'
    | '1.3'
    | '1.4'
    | '2.0'
    | '2.1'
    | '2.2'
    | '2.3'
    | '2.4'
    | '2.5'
    | '2.6'
    | '2.7'
    | '2.8'
    | '2.9'
    | '2.10'
    | 'Unstable';
}

export namespace ConversationUpdateParams {
  /**
   * An instance of a Custom Object Type.
   */
  export interface CustomObjectInstance {
    /**
     * The Intercom defined id representing the custom object instance.
     */
    id?: string;

    /**
     * The custom attributes you have set on the custom object instance.
     */
    custom_attributes?: Record<string, string>;

    /**
     * The id you have defined for the custom object instance.
     */
    external_id?: string;

    /**
     * The identifier of the custom object type that defines the structure of the
     * custom object instance.
     */
    type?: string;
  }
}

export interface ConversationListParams {
  /**
   * Query param: How many results per page
   */
  per_page?: number;

  /**
   * Query param: String used to get the next page of conversations.
   */
  starting_after?: string;

  /**
   * Header param: Intercom API version.</br>By default, it's equal to the version
   * set in the app package.
   */
  'Intercom-Version'?:
    | '1.0'
    | '1.1'
    | '1.2'
    | '1.3'
    | '1.4'
    | '2.0'
    | '2.1'
    | '2.2'
    | '2.3'
    | '2.4'
    | '2.5'
    | '2.6'
    | '2.7'
    | '2.8'
    | '2.9'
    | '2.10'
    | 'Unstable';
}

export interface ConversationDeleteParams {
  /**
   * Intercom API version.</br>By default, it's equal to the version set in the app
   * package.
   */
  'Intercom-Version'?:
    | '1.0'
    | '1.1'
    | '1.2'
    | '1.3'
    | '1.4'
    | '2.0'
    | '2.1'
    | '2.2'
    | '2.3'
    | '2.4'
    | '2.5'
    | '2.6'
    | '2.7'
    | '2.8'
    | '2.9'
    | '2.10'
    | 'Unstable';
}

export interface ConversationConvertParams {
  /**
   * Body param: The ID of the type of ticket you want to convert the conversation to
   */
  ticket_type_id: string;

  /**
   * Body param: The attributes set on the ticket. When setting the default title and
   * description attributes, the attribute keys that should be used are
   * `_default_title_` and `_default_description_`. When setting ticket type
   * attributes of the list attribute type, the key should be the attribute name and
   * the value of the attribute should be the list item id, obtainable by
   * [listing the ticket type](ref:get_ticket-types). For example, if the ticket type
   * has an attribute called `priority` of type `list`, the key should be `priority`
   * and the value of the attribute should be the guid of the list item (e.g.
   * `de1825a0-0164-4070-8ca6-13e22462fa7e`).
   */
  attributes?: Record<string, string | null | number | boolean | Array<unknown>>;

  /**
   * Header param: Intercom API version.</br>By default, it's equal to the version
   * set in the app package.
   */
  'Intercom-Version'?:
    | '1.0'
    | '1.1'
    | '1.2'
    | '1.3'
    | '1.4'
    | '2.0'
    | '2.1'
    | '2.2'
    | '2.3'
    | '2.4'
    | '2.5'
    | '2.6'
    | '2.7'
    | '2.8'
    | '2.9'
    | '2.10'
    | 'Unstable';
}

export type ConversationRedactParams = ConversationRedactParams.Variant0 | ConversationRedactParams.Variant1;

export namespace ConversationRedactParams {
  export interface Variant0 {
    /**
     * Body param: The id of the conversation.
     */
    conversation_id: string;

    /**
     * Body param: The id of the conversation_part.
     */
    conversation_part_id: string;

    /**
     * Body param: The type of resource being redacted.
     */
    type: 'conversation_part';

    /**
     * Header param: Intercom API version.</br>By default, it's equal to the version
     * set in the app package.
     */
    'Intercom-Version'?:
      | '1.0'
      | '1.1'
      | '1.2'
      | '1.3'
      | '1.4'
      | '2.0'
      | '2.1'
      | '2.2'
      | '2.3'
      | '2.4'
      | '2.5'
      | '2.6'
      | '2.7'
      | '2.8'
      | '2.9'
      | '2.10'
      | 'Unstable';
  }

  export interface Variant1 {
    /**
     * Body param: The id of the conversation.
     */
    conversation_id: string;

    /**
     * Body param: The id of the source.
     */
    source_id: string;

    /**
     * Body param: The type of resource being redacted.
     */
    type: 'source';

    /**
     * Header param: Intercom API version.</br>By default, it's equal to the version
     * set in the app package.
     */
    'Intercom-Version'?:
      | '1.0'
      | '1.1'
      | '1.2'
      | '1.3'
      | '1.4'
      | '2.0'
      | '2.1'
      | '2.2'
      | '2.3'
      | '2.4'
      | '2.5'
      | '2.6'
      | '2.7'
      | '2.8'
      | '2.9'
      | '2.10'
      | 'Unstable';
  }
}

export namespace Conversations {
  export import ConversationDeleted = ConversationsAPI.ConversationDeleted;
  export import ConversationCreateParams = ConversationsAPI.ConversationCreateParams;
  export import ConversationRetrieveParams = ConversationsAPI.ConversationRetrieveParams;
  export import ConversationUpdateParams = ConversationsAPI.ConversationUpdateParams;
  export import ConversationListParams = ConversationsAPI.ConversationListParams;
  export import ConversationDeleteParams = ConversationsAPI.ConversationDeleteParams;
  export import ConversationConvertParams = ConversationsAPI.ConversationConvertParams;
  export import ConversationRedactParams = ConversationsAPI.ConversationRedactParams;
  export import Tags = TagsAPI.Tags;
  export import TagCreateParams = TagsAPI.TagCreateParams;
  export import TagDeleteParams = TagsAPI.TagDeleteParams;
  export import Search = SearchAPI.Search;
  export import ConversationList = SearchAPI.ConversationList;
  export import SearchCreateParams = SearchAPI.SearchCreateParams;
  export import Reply = ReplyAPI.Reply;
  export import ReplyCreateParams = ReplyAPI.ReplyCreateParams;
  export import Parts = PartsAPI.Parts;
  export import PartCreateParams = PartsAPI.PartCreateParams;
  export import RunAssignmentRules = RunAssignmentRulesAPI.RunAssignmentRules;
  export import RunAssignmentRuleCreateParams = RunAssignmentRulesAPI.RunAssignmentRuleCreateParams;
  export import Customers = CustomersAPI.Customers;
  export import CustomerCreateParams = CustomersAPI.CustomerCreateParams;
}
