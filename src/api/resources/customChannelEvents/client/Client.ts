/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Intercom from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace CustomChannelEvents {
    export interface Options {
        environment?: core.Supplier<environments.IntercomEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the Intercom-Version header */
        version?:
            | "1.0"
            | "1.1"
            | "1.2"
            | "1.3"
            | "1.4"
            | "2.0"
            | "2.1"
            | "2.2"
            | "2.3"
            | "2.4"
            | "2.5"
            | "2.6"
            | "2.7"
            | "2.8"
            | "2.9"
            | "2.10"
            | "2.11"
            | "2.12"
            | "2.13"
            | "2.14"
            | "Unstable";
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
        /** Override the Intercom-Version header */
        version?:
            | "1.0"
            | "1.1"
            | "1.2"
            | "1.3"
            | "1.4"
            | "2.0"
            | "2.1"
            | "2.2"
            | "2.3"
            | "2.4"
            | "2.5"
            | "2.6"
            | "2.7"
            | "2.8"
            | "2.9"
            | "2.10"
            | "2.11"
            | "2.12"
            | "2.13"
            | "2.14"
            | "Unstable";
    }
}

/**
 * With the "Custom Channel" integration, you can bring Fin and Intercom capabilities to your own platform via API, enabling powerful custom integrations.
 *
 * Intercom treats your integration like any other Intercom channel, allowing your application and Intercom to exchange events seamlessly. This makes it possible, for example, for your users to interact with Fin directly within your own applicationâ€™s UI.
 *
 * > **Note:** "Fin over API" is currently under managed availability. Please reach out to your accounts team to discuss access and tailored, hands-on support.
 */
export class CustomChannelEvents {
    constructor(protected readonly _options: CustomChannelEvents.Options = {}) {}

    /**
     * Notifies Intercom that a new conversation was created in your custom channel/platform. This triggers conversation creation and workflow automations within Intercom for your custom channel integration.
     * > **Note:** This endpoint is currently under managed availability. Please reach out to your accounts team to discuss access and tailored, hands-on support.
     *
     * @param {Intercom.CustomChannelBaseEvent} request
     * @param {CustomChannelEvents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.BadRequestError}
     * @throws {@link Intercom.UnauthorizedError}
     * @throws {@link Intercom.NotFoundError}
     * @throws {@link Intercom.UnprocessableEntityError}
     *
     * @example
     *     await client.customChannelEvents.notifyNewConversation({
     *         event_id: "event_id",
     *         external_conversation_id: "external_conversation_id",
     *         contact: {
     *             type: "user",
     *             external_id: "external_id",
     *             name: undefined,
     *             email: undefined
     *         }
     *     })
     */
    public notifyNewConversation(
        request: Intercom.CustomChannelBaseEvent,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): core.HttpResponsePromise<Intercom.CustomChannelNotificationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__notifyNewConversation(request, requestOptions));
    }

    private async __notifyNewConversation(
        request: Intercom.CustomChannelBaseEvent,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): Promise<core.WithRawResponse<Intercom.CustomChannelNotificationResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                "custom_channel_events/notify_new_conversation",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.5.0",
                "User-Agent": "intercom-client/6.5.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.14",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Intercom.CustomChannelNotificationResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Intercom.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Intercom.UnauthorizedError(
                        _response.error.body as Intercom.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Intercom.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Intercom.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError(
                    "Timeout exceeded when calling POST /custom_channel_events/notify_new_conversation.",
                );
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Notifies Intercom that a new message was sent in a conversation on your custom channel/platform. This allows Intercom to process the message and trigger any relevant workflow automations.
     * > **Note:** This endpoint is currently under managed availability. Please reach out to your accounts team to discuss access and tailored, hands-on support.
     *
     * @param {Intercom.NotifyNewMessageRequest} request
     * @param {CustomChannelEvents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.BadRequestError}
     * @throws {@link Intercom.UnauthorizedError}
     * @throws {@link Intercom.NotFoundError}
     * @throws {@link Intercom.UnprocessableEntityError}
     *
     * @example
     *     await client.customChannelEvents.notifyNewMessage({
     *         body: "body",
     *         event_id: "event_id",
     *         external_conversation_id: "external_conversation_id",
     *         contact: {
     *             type: "user",
     *             external_id: "external_id",
     *             name: undefined,
     *             email: undefined
     *         }
     *     })
     */
    public notifyNewMessage(
        request: Intercom.NotifyNewMessageRequest,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): core.HttpResponsePromise<Intercom.CustomChannelNotificationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__notifyNewMessage(request, requestOptions));
    }

    private async __notifyNewMessage(
        request: Intercom.NotifyNewMessageRequest,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): Promise<core.WithRawResponse<Intercom.CustomChannelNotificationResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                "custom_channel_events/notify_new_message",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.5.0",
                "User-Agent": "intercom-client/6.5.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.14",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Intercom.CustomChannelNotificationResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Intercom.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Intercom.UnauthorizedError(
                        _response.error.body as Intercom.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Intercom.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Intercom.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError(
                    "Timeout exceeded when calling POST /custom_channel_events/notify_new_message.",
                );
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Notifies Intercom that a user selected a quick reply option in your custom channel/platform. This allows Intercom to process the response and trigger any relevant workflow automations.
     * > **Note:** This endpoint is currently under managed availability. Please reach out to your accounts team to discuss access and tailored, hands-on support.
     *
     * @param {Intercom.NotifyQuickReplySelectedRequest} request
     * @param {CustomChannelEvents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.BadRequestError}
     * @throws {@link Intercom.UnauthorizedError}
     * @throws {@link Intercom.NotFoundError}
     * @throws {@link Intercom.UnprocessableEntityError}
     *
     * @example
     *     await client.customChannelEvents.notifyQuickReplySelected({
     *         event_id: "evt_67890",
     *         external_conversation_id: "conv_13579",
     *         contact: {
     *             type: "user",
     *             external_id: "user_003",
     *             name: "Alice Example",
     *             email: "alice@example.com"
     *         },
     *         quick_reply_option_id: "1234"
     *     })
     */
    public notifyQuickReplySelected(
        request: Intercom.NotifyQuickReplySelectedRequest,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): core.HttpResponsePromise<Intercom.CustomChannelNotificationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__notifyQuickReplySelected(request, requestOptions));
    }

    private async __notifyQuickReplySelected(
        request: Intercom.NotifyQuickReplySelectedRequest,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): Promise<core.WithRawResponse<Intercom.CustomChannelNotificationResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                "custom_channel_events/notify_quick_reply_selected",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.5.0",
                "User-Agent": "intercom-client/6.5.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.14",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Intercom.CustomChannelNotificationResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Intercom.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Intercom.UnauthorizedError(
                        _response.error.body as Intercom.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Intercom.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Intercom.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError(
                    "Timeout exceeded when calling POST /custom_channel_events/notify_quick_reply_selected.",
                );
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Notifies Intercom that a user provided a response to an attribute collector in your custom channel/platform. This allows Intercom to process the attribute and trigger any relevant workflow automations.
     * > **Note:** This endpoint is currently under managed availability. Please reach out to your accounts team to discuss access and tailored, hands-on support.
     *
     * @param {Intercom.NotifyAttributeCollectedRequest} request
     * @param {CustomChannelEvents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.BadRequestError}
     * @throws {@link Intercom.UnauthorizedError}
     * @throws {@link Intercom.NotFoundError}
     * @throws {@link Intercom.UnprocessableEntityError}
     *
     * @example
     *     await client.customChannelEvents.notifyAttributeCollected({
     *         attribute: {
     *             id: "id",
     *             value: "value"
     *         },
     *         event_id: "event_id",
     *         external_conversation_id: "external_conversation_id",
     *         contact: {
     *             type: "user",
     *             external_id: "external_id",
     *             name: undefined,
     *             email: undefined
     *         }
     *     })
     */
    public notifyAttributeCollected(
        request: Intercom.NotifyAttributeCollectedRequest,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): core.HttpResponsePromise<Intercom.CustomChannelNotificationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__notifyAttributeCollected(request, requestOptions));
    }

    private async __notifyAttributeCollected(
        request: Intercom.NotifyAttributeCollectedRequest,
        requestOptions?: CustomChannelEvents.RequestOptions,
    ): Promise<core.WithRawResponse<Intercom.CustomChannelNotificationResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                "custom_channel_events/notify_attribute_collected",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.5.0",
                "User-Agent": "intercom-client/6.5.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.14",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Intercom.CustomChannelNotificationResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Intercom.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Intercom.UnauthorizedError(
                        _response.error.body as Intercom.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Intercom.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Intercom.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError(
                    "Timeout exceeded when calling POST /custom_channel_events/notify_attribute_collected.",
                );
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        const bearer = (await core.Supplier.get(this._options.token)) ?? process?.env["INTERCOM_API_KEY"];
        if (bearer == null) {
            throw new errors.IntercomError({
                message:
                    "Please specify a bearer by either passing it in to the constructor or initializing a INTERCOM_API_KEY environment variable",
            });
        }

        return `Bearer ${bearer}`;
    }
}
