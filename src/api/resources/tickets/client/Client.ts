/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Intercom from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace Tickets {
    export interface Options {
        environment?: core.Supplier<environments.IntercomEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the Intercom-Version header */
        version?:
            | "1.0"
            | "1.1"
            | "1.2"
            | "1.3"
            | "1.4"
            | "2.0"
            | "2.1"
            | "2.2"
            | "2.3"
            | "2.4"
            | "2.5"
            | "2.6"
            | "2.7"
            | "2.8"
            | "2.9"
            | "2.10"
            | "2.11"
            | "Unstable";
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
        /** Override the Intercom-Version header */
        version?:
            | "1.0"
            | "1.1"
            | "1.2"
            | "1.3"
            | "1.4"
            | "2.0"
            | "2.1"
            | "2.2"
            | "2.3"
            | "2.4"
            | "2.5"
            | "2.6"
            | "2.7"
            | "2.8"
            | "2.9"
            | "2.10"
            | "2.11"
            | "Unstable";
    }
}

/**
 * Everything about your tickets
 */
export class Tickets {
    constructor(protected readonly _options: Tickets.Options = {}) {}

    /**
     * You can reply to a ticket with a message from an admin or on behalf of a contact, or with a note for admins.
     *
     * @param {Intercom.ReplyToTicketRequest} request
     * @param {Tickets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.BadRequestError}
     * @throws {@link Intercom.UnauthorizedError}
     * @throws {@link Intercom.NotFoundError}
     *
     * @example
     *     await client.tickets.reply({
     *         ticket_id: "123",
     *         body: {
     *             message_type: "comment",
     *             type: "user",
     *             body: "Thanks again :)",
     *             intercom_user_id: "667d619d8a68186f43bafe82"
     *         }
     *     })
     *
     * @example
     *     await client.tickets.reply({
     *         ticket_id: "123",
     *         body: {
     *             message_type: "note",
     *             type: "admin",
     *             body: "<html> <body>  <h2>An Unordered HTML List</h2>  <ul>   <li>Coffee</li>   <li>Tea</li>   <li>Milk</li> </ul>    <h2>An Ordered HTML List</h2>  <ol>   <li>Coffee</li>   <li>Tea</li>   <li>Milk</li> </ol>   </body> </html>",
     *             admin_id: "3156780"
     *         }
     *     })
     *
     * @example
     *     await client.tickets.reply({
     *         ticket_id: "123",
     *         body: {
     *             message_type: "quick_reply",
     *             type: "admin",
     *             admin_id: "3156780",
     *             reply_options: [{
     *                     text: "Yes",
     *                     uuid: "22d6d1f4-1a19-41d0-94c2-e54031f78aca"
     *                 }, {
     *                     text: "No",
     *                     uuid: "fbc3dbe0-ec0c-4fb6-826d-e19127191906"
     *                 }]
     *         }
     *     })
     *
     * @example
     *     await client.tickets.reply({
     *         ticket_id: "123",
     *         body: {
     *             message_type: "comment",
     *             type: "user",
     *             body: "Thanks again :)",
     *             intercom_user_id: "667d61a68a68186f43bafe85"
     *         }
     *     })
     */
    public async reply(
        request: Intercom.ReplyToTicketRequest,
        requestOptions?: Tickets.RequestOptions,
    ): Promise<Intercom.TicketReply> {
        const { ticket_id: ticketId, body: _body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                `tickets/${encodeURIComponent(ticketId)}/reply`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.2.0",
                "User-Agent": "intercom-client/6.2.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as Intercom.TicketReply;
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Intercom.BadRequestError(_response.error.body as unknown);
                case 401:
                    throw new Intercom.UnauthorizedError(_response.error.body as Intercom.Error_);
                case 404:
                    throw new Intercom.NotFoundError(_response.error.body as unknown);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError("Timeout exceeded when calling POST /tickets/{ticket_id}/reply.");
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * You can create a new ticket.
     *
     * @param {Intercom.CreateTicketRequest} request
     * @param {Tickets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.UnauthorizedError}
     *
     * @example
     *     await client.tickets.create({
     *         ticket_type_id: "1234",
     *         contacts: [{
     *                 id: "667d61b78a68186f43bafe8d"
     *             }],
     *         ticket_attributes: {
     *             "_default_title_": "example",
     *             "_default_description_": "there is a problem"
     *         }
     *     })
     */
    public async create(
        request: Intercom.CreateTicketRequest,
        requestOptions?: Tickets.RequestOptions,
    ): Promise<Intercom.Ticket> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                "tickets",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.2.0",
                "User-Agent": "intercom-client/6.2.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as Intercom.Ticket;
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Intercom.UnauthorizedError(_response.error.body as Intercom.Error_);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError("Timeout exceeded when calling POST /tickets.");
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * You can fetch the details of a single ticket.
     *
     * @param {Intercom.FindTicketRequest} request
     * @param {Tickets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.UnauthorizedError}
     *
     * @example
     *     await client.tickets.get({
     *         ticket_id: "ticket_id"
     *     })
     */
    public async get(
        request: Intercom.FindTicketRequest,
        requestOptions?: Tickets.RequestOptions,
    ): Promise<Intercom.Ticket> {
        const { ticket_id: ticketId } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                `tickets/${encodeURIComponent(ticketId)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.2.0",
                "User-Agent": "intercom-client/6.2.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as Intercom.Ticket;
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Intercom.UnauthorizedError(_response.error.body as Intercom.Error_);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError("Timeout exceeded when calling GET /tickets/{ticket_id}.");
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * You can update a ticket.
     *
     * @param {Intercom.UpdateTicketRequest} request
     * @param {Tickets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Intercom.UnauthorizedError}
     * @throws {@link Intercom.NotFoundError}
     *
     * @example
     *     await client.tickets.update({
     *         ticket_id: "ticket_id",
     *         ticket_attributes: {
     *             "_default_title_": "example",
     *             "_default_description_": "there is a problem"
     *         },
     *         state: "in_progress",
     *         open: true,
     *         snoozed_until: 1673609604,
     *         assignment: {
     *             admin_id: "991267883",
     *             assignee_id: "991267885"
     *         }
     *     })
     *
     * @example
     *     await client.tickets.update({
     *         ticket_id: "ticket_id",
     *         ticket_attributes: {
     *             "_default_title_": "example",
     *             "_default_description_": "there is a problem"
     *         },
     *         state: "in_progress",
     *         assignment: {
     *             admin_id: "123",
     *             assignee_id: "991267893"
     *         }
     *     })
     *
     * @example
     *     await client.tickets.update({
     *         ticket_id: "ticket_id",
     *         ticket_attributes: {
     *             "_default_title_": "example",
     *             "_default_description_": "there is a problem"
     *         },
     *         state: "in_progress",
     *         assignment: {
     *             admin_id: "991267899",
     *             assignee_id: "456"
     *         }
     *     })
     */
    public async update(
        request: Intercom.UpdateTicketRequest,
        requestOptions?: Tickets.RequestOptions,
    ): Promise<Intercom.Ticket> {
        const { ticket_id: ticketId, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.IntercomEnvironment.UsProduction,
                `tickets/${encodeURIComponent(ticketId)}`,
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "intercom-client",
                "X-Fern-SDK-Version": "6.2.0",
                "User-Agent": "intercom-client/6.2.0",
                "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as Intercom.Ticket;
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Intercom.UnauthorizedError(_response.error.body as Intercom.Error_);
                case 404:
                    throw new Intercom.NotFoundError(_response.error.body as unknown);
                default:
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.IntercomTimeoutError("Timeout exceeded when calling PUT /tickets/{ticket_id}.");
            case "unknown":
                throw new errors.IntercomError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * You can search for multiple tickets by the value of their attributes in order to fetch exactly which ones you want.
     *
     * To search for tickets, you send a `POST` request to `https://api.intercom.io/tickets/search`.
     *
     * This will accept a query object in the body which will define your filters.
     * {% admonition type="warning" name="Optimizing search queries" %}
     *   Search queries can be complex, so optimizing them can help the performance of your search.
     *   Use the `AND` and `OR` operators to combine multiple filters to get the exact results you need and utilize
     *   pagination to limit the number of results returned. The default is `20` results per page.
     *   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#example-search-conversations-request) for more details on how to use the `starting_after` param.
     * {% /admonition %}
     *
     * ### Nesting & Limitations
     *
     * You can nest these filters in order to get even more granular insights that pinpoint exactly what you need. Example: (1 OR 2) AND (3 OR 4).
     * There are some limitations to the amount of multiples there can be:
     * - There's a limit of max 2 nested filters
     * - There's a limit of max 15 filters for each AND or OR group
     *
     * ### Accepted Fields
     *
     * Most keys listed as part of the Ticket model are searchable, whether writeable or not. The value you search for has to match the accepted type, otherwise the query will fail (ie. as `created_at` accepts a date, the `value` cannot be a string such as `"foobar"`).
     *
     * | Field                                     | Type                                                                                     |
     * | :---------------------------------------- | :--------------------------------------------------------------------------------------- |
     * | id                                        | String                                                                                   |
     * | created_at                                | Date (UNIX timestamp)                                                                    |
     * | updated_at                                | Date (UNIX timestamp)                                                                    |
     * | _default_title_                           | String                                                                                   |
     * | _default_description_                     | String                                                                                   |
     * | category                                  | String                                                                                   |
     * | ticket_type_id                            | String                                                                                   |
     * | contact_ids                               | String                                                                                   |
     * | teammate_ids                              | String                                                                                   |
     * | admin_assignee_id                         | String                                                                                   |
     * | team_assignee_id                          | String                                                                                   |
     * | open                                      | Boolean                                                                                  |
     * | state                                     | String                                                                                   |
     * | snoozed_until                             | Date (UNIX timestamp)                                                                    |
     * | ticket_attribute.{id}                     | String or Boolean or Date (UNIX timestamp) or Float or Integer                           |
     *
     * ### Accepted Operators
     *
     * {% admonition type="info" name="Searching based on `created_at`" %}
     *   You may use the `<=` or `>=` operators to search by `created_at`.
     * {% /admonition %}
     *
     * The table below shows the operators you can use to define how you want to search for the value.  The operator should be put in as a string (`"="`). The operator has to be compatible with the field's type  (eg. you cannot search with `>` for a given string value as it's only compatible for integer's and dates).
     *
     * | Operator | Valid Types                    | Description                                                  |
     * | :------- | :----------------------------- | :----------------------------------------------------------- |
     * | =        | All                            | Equals                                                       |
     * | !=       | All                            | Doesn't Equal                                                |
     * | IN       | All                            | In  Shortcut for `OR` queries  Values most be in Array       |
     * | NIN      | All                            | Not In  Shortcut for `OR !` queries  Values must be in Array |
     * | >        | Integer  Date (UNIX Timestamp) | Greater (or equal) than                                      |
     * | <       | Integer  Date (UNIX Timestamp) | Lower (or equal) than                                        |
     * | ~        | String                         | Contains                                                     |
     * | !~       | String                         | Doesn't Contain                                              |
     * | ^        | String                         | Starts With                                                  |
     * | $        | String                         | Ends With                                                    |
     *
     * @param {Intercom.SearchRequest} request
     * @param {Tickets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.tickets.search({
     *         query: {
     *             operator: "AND",
     *             value: [{
     *                     field: "created_at",
     *                     operator: ">",
     *                     value: "1306054154"
     *                 }]
     *         },
     *         pagination: {
     *             per_page: 5
     *         }
     *     })
     */
    public async search(
        request: Intercom.SearchRequest,
        requestOptions?: Tickets.RequestOptions,
    ): Promise<core.Page<Intercom.Ticket>> {
        const list = async (request: Intercom.SearchRequest): Promise<Intercom.TicketList> => {
            const _response = await (this._options.fetcher ?? core.fetcher)({
                url: urlJoin(
                    (await core.Supplier.get(this._options.baseUrl)) ??
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.IntercomEnvironment.UsProduction,
                    "tickets/search",
                ),
                method: "POST",
                headers: {
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-SDK-Name": "intercom-client",
                    "X-Fern-SDK-Version": "6.2.0",
                    "User-Agent": "intercom-client/6.2.0",
                    "Intercom-Version": requestOptions?.version ?? this._options?.version ?? "2.11",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                    ...requestOptions?.headers,
                },
                contentType: "application/json",
                requestType: "json",
                body: request,
                timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 20000,
                maxRetries: requestOptions?.maxRetries,
                abortSignal: requestOptions?.abortSignal,
            });
            if (_response.ok) {
                return _response.body as Intercom.TicketList;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.IntercomError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.IntercomError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.IntercomTimeoutError("Timeout exceeded when calling POST /tickets/search.");
                case "unknown":
                    throw new errors.IntercomError({
                        message: _response.error.errorMessage,
                    });
            }
        };
        return new core.Pageable<Intercom.TicketList, Intercom.Ticket>({
            response: await list(request),
            hasNextPage: (response) => response?.pages?.next?.starting_after != null,
            getItems: (response) => response?.tickets ?? [],
            loadPage: (response) => {
                return list(
                    core.setObjectProperty(request, "pagination.starting_after", response?.pages?.next?.starting_after),
                );
            },
        });
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        const bearer = (await core.Supplier.get(this._options.token)) ?? process?.env["INTERCOM_API_KEY"];
        if (bearer == null) {
            throw new errors.IntercomError({
                message:
                    "Please specify a bearer by either passing it in to the constructor or initializing a INTERCOM_API_KEY environment variable",
            });
        }

        return `Bearer ${bearer}`;
    }
}
